// Backend/frontend logs
let _startTime = datetime("{{.StartTime}}");
let _endTime = datetime("{{.EndTime}}");
let _resource_group = '{{.ResourceGroupName}}';
let cluster_resource_id = (database('ServiceLogs').table('frontendLogs')
| where timestamp between (_startTime .. _endTime)
| where resource_group == _resource_group
| where msg has 'creating resource'
| extend resource_id=extract(@"creating resource ([A-Za-z0-9\-\.\/]+)", 1, tostring(log)) 
| distinct tostring(resource_id)
| limit 1);
union
    (
        database('ServiceLogs').table('backendLogs')
        | where timestamp between (_startTime .. _endTime)
        | where resource_id in (cluster_resource_id)
        | project timestamp, container_name, msg, log
    ),
    (
        database('ServiceLogs').table('frontendLogs')
        | where timestamp between (_startTime .. _endTime)
        | where resource_group == _resource_group
        | project timestamp, container_name, msg, log
    )
    | order by timestamp asc

// CS Specific logs
let _startTime = datetime("{{.StartTime}}");
let _endTime = datetime("{{.EndTime}}");
let _resource_group = '{{.ResourceGroupName}}';
    (
        database('ServiceLogs').table('clustersServiceLogs')
        | where timestamp between (_startTime .. _endTime)
        | where resource_id has _resource_group  
        | project timestamp, container_name, msg, log
        | order by timestamp asc 
    )

// HostedCluster conditions (as seen by CS)
let _startTime = datetime("{{.StartTime}}");
let _endTime = datetime("{{.EndTime}}");
let _resource_group = '{{.ResourceGroupName}}';
    (
        database('ServiceLogs').table('clustersServiceLogs')
        | where timestamp between (_startTime .. _endTime)
        | where resource_id has _resource_group
        | extend extracted=extract_all(@'{"name":"([A-Za-z0-9]+)-Message","fieldValue":{"type":"String","string":"([^"]+)"}}', dynamic([1,2]), tostring(msg))
        | mv-expand matches = extracted to typeof(dynamic)
        | extend status_name = tostring(matches[0])
        | extend status_message = tostring(matches[1])
        | where status_name != "" and status_message != ""
        | project timestamp, status_name, status_message
        | summarize arg_min(timestamp, *) by status_name, status_message
        | order by timestamp asc
        | project-reorder timestamp, status_name, status_message
    )