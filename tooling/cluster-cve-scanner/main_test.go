// Copyright 2025 Microsoft Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"os"
	"path/filepath"
	"testing"
)

func TestParseImageReference(t *testing.T) {
	tests := []struct {
		name             string
		image            string
		expectedRegistry string
		expectedName     string
		expectedSHA      string
	}{
		{
			name:             "image with registry, name, and SHA",
			image:            "registry.redhat.io/openshift4/ose-cluster-version-operator@sha256:abc123",
			expectedRegistry: "registry.redhat.io",
			expectedName:     "openshift4/ose-cluster-version-operator",
			expectedSHA:      "sha256:abc123",
		},
		{
			name:             "image with registry port and SHA",
			image:            "registry.redhat.io:443/openshift4/ose-cluster-version-operator@sha256:abc123",
			expectedRegistry: "registry.redhat.io",
			expectedName:     "openshift4/ose-cluster-version-operator",
			expectedSHA:      "sha256:abc123",
		},
		{
			name:             "image with tag instead of SHA",
			image:            "registry.redhat.io/openshift4/ose-cluster-version-operator:v4.12",
			expectedRegistry: "registry.redhat.io",
			expectedName:     "openshift4/ose-cluster-version-operator",
			expectedSHA:      "v4.12",
		},
		{
			name:             "image with registry port and tag",
			image:            "registry.redhat.io:443/openshift4/ose-cluster-version-operator:v4.12",
			expectedRegistry: "registry.redhat.io",
			expectedName:     "openshift4/ose-cluster-version-operator",
			expectedSHA:      "v4.12",
		},
		{
			name:             "image without version defaults to latest",
			image:            "registry.redhat.io/openshift4/ose-cluster-version-operator",
			expectedRegistry: "registry.redhat.io",
			expectedName:     "openshift4/ose-cluster-version-operator",
			expectedSHA:      "latest",
		},
		{
			name:             "image without registry defaults to docker.io",
			image:            "nginx:latest",
			expectedRegistry: "docker.io",
			expectedName:     "nginx",
			expectedSHA:      "latest",
		},
		{
			name:             "simple image name without registry or tag",
			image:            "nginx",
			expectedRegistry: "docker.io",
			expectedName:     "nginx",
			expectedSHA:      "latest",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			registry, name, sha := parseImageReference(tt.image)

			if registry != tt.expectedRegistry {
				t.Errorf("parseImageReference() registry = %v, want %v", registry, tt.expectedRegistry)
			}
			if name != tt.expectedName {
				t.Errorf("parseImageReference() name = %v, want %v", name, tt.expectedName)
			}
			if sha != tt.expectedSHA {
				t.Errorf("parseImageReference() sha = %v, want %v", sha, tt.expectedSHA)
			}
		})
	}
}

func TestApplyRegistrySubstitutions(t *testing.T) {
	tests := []struct {
		name          string
		image         string
		substitutions map[string]string
		expected      string
	}{
		{
			name:  "substitute registry.redhat.io",
			image: "registry.redhat.io/openshift4/ose-cluster-version-operator@sha256:abc123",
			substitutions: map[string]string{
				"registry.redhat.io": "registry.stage.redhat.io",
			},
			expected: "registry.stage.redhat.io/openshift4/ose-cluster-version-operator@sha256:abc123",
		},
		{
			name:  "substitute registry with port",
			image: "registry.redhat.io:443/openshift4/ose-cluster-version-operator@sha256:abc123",
			substitutions: map[string]string{
				"registry.redhat.io": "registry.stage.redhat.io",
			},
			expected: "registry.stage.redhat.io/openshift4/ose-cluster-version-operator@sha256:abc123",
		},
		{
			name:  "no substitution when registry doesn't match",
			image: "quay.io/openshift/something:latest",
			substitutions: map[string]string{
				"registry.redhat.io": "registry.stage.redhat.io",
			},
			expected: "quay.io/openshift/something:latest",
		},
		{
			name:          "no substitution with nil map",
			image:         "registry.redhat.io/openshift4/ose-cluster-version-operator@sha256:abc123",
			substitutions: nil,
			expected:      "registry.redhat.io/openshift4/ose-cluster-version-operator@sha256:abc123",
		},
		{
			name:          "no substitution with empty map",
			image:         "registry.redhat.io/openshift4/ose-cluster-version-operator@sha256:abc123",
			substitutions: map[string]string{},
			expected:      "registry.redhat.io/openshift4/ose-cluster-version-operator@sha256:abc123",
		},
		{
			name:  "multiple substitutions with correct match",
			image: "registry.redhat.io/openshift4/ose-cluster-version-operator@sha256:abc123",
			substitutions: map[string]string{
				"quay.io":            "custom.quay.io",
				"registry.redhat.io": "registry.stage.redhat.io",
				"gcr.io":             "custom.gcr.io",
			},
			expected: "registry.stage.redhat.io/openshift4/ose-cluster-version-operator@sha256:abc123",
		},
		{
			name:  "image without registry (no slash)",
			image: "nginx:latest",
			substitutions: map[string]string{
				"docker.io": "custom.docker.io",
			},
			expected: "nginx:latest",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := applyRegistrySubstitutions(tt.image, tt.substitutions)
			if result != tt.expected {
				t.Errorf("applyRegistrySubstitutions() = %v, want %v", result, tt.expected)
			}
		})
	}
}

func TestLoadConfig(t *testing.T) {
	// Create a temporary config file for testing
	tempDir := t.TempDir()
	configPath := filepath.Join(tempDir, "test-config.yaml")

	configContent := `namespaces:
  - open-cluster-management*
  - hive
  - hypershift

registry_substitutions:
  registry.redhat.io: registry.stage.redhat.io
  quay.io: custom.quay.io
`

	if err := os.WriteFile(configPath, []byte(configContent), 0644); err != nil {
		t.Fatalf("Failed to create test config file: %v", err)
	}

	t.Run("valid config file", func(t *testing.T) {
		config, err := loadConfig(configPath)
		if err != nil {
			t.Fatalf("loadConfig() error = %v", err)
		}

		if len(config.Namespaces) != 3 {
			t.Errorf("Expected 3 namespaces, got %d", len(config.Namespaces))
		}

		expectedNamespaces := []string{"open-cluster-management*", "hive", "hypershift"}
		for i, ns := range expectedNamespaces {
			if config.Namespaces[i] != ns {
				t.Errorf("Namespace[%d] = %v, want %v", i, config.Namespaces[i], ns)
			}
		}

		if len(config.RegistrySubstitutions) != 2 {
			t.Errorf("Expected 2 registry substitutions, got %d", len(config.RegistrySubstitutions))
		}

		if config.RegistrySubstitutions["registry.redhat.io"] != "registry.stage.redhat.io" {
			t.Errorf("Registry substitution for registry.redhat.io = %v, want registry.stage.redhat.io",
				config.RegistrySubstitutions["registry.redhat.io"])
		}
	})

	t.Run("non-existent config file", func(t *testing.T) {
		_, err := loadConfig(filepath.Join(tempDir, "nonexistent.yaml"))
		if err == nil {
			t.Error("Expected error for non-existent file, got nil")
		}
	})

	t.Run("invalid yaml config", func(t *testing.T) {
		invalidConfigPath := filepath.Join(tempDir, "invalid-config.yaml")
		invalidContent := `namespaces:
  - foo
  invalid yaml content: [[[
`
		if err := os.WriteFile(invalidConfigPath, []byte(invalidContent), 0644); err != nil {
			t.Fatalf("Failed to create invalid config file: %v", err)
		}

		_, err := loadConfig(invalidConfigPath)
		if err == nil {
			t.Error("Expected error for invalid YAML, got nil")
		}
	})
}

func TestOutputJSON(t *testing.T) {
	tempDir := t.TempDir()
	outputFile := filepath.Join(tempDir, "test-output.json")
	timestamp := "2025-10-22T12:00:00Z"

	results := []ImageCVE{
		{
			Registry: "registry.redhat.io",
			Name:     "openshift4/ose-operator",
			SHA:      "sha256:abc123",
			CVEs: CVEsBySeverity{
				Critical: []string{"CVE-2024-0001"},
				High:     []string{"CVE-2024-0002", "CVE-2024-0003"},
				Medium:   []string{},
				Low:      []string{},
			},
		},
	}

	err := outputJSON(results, outputFile, timestamp)
	if err != nil {
		t.Fatalf("outputJSON() error = %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		t.Error("Output file was not created")
	}

	// Read and verify content
	content, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatalf("Failed to read output file: %v", err)
	}

	// Basic validation - check if it contains expected strings
	contentStr := string(content)
	expectedStrings := []string{
		`"generated_at": "2025-10-22T12:00:00Z"`,
		`"image_count": 1`,
		`"registry": "registry.redhat.io"`,
		`"CVE-2024-0001"`,
	}

	for _, expected := range expectedStrings {
		if !contains(contentStr, expected) {
			t.Errorf("Output JSON missing expected string: %s", expected)
		}
	}
}

func TestOutputCSV(t *testing.T) {
	tempDir := t.TempDir()
	outputFile := filepath.Join(tempDir, "test-output.csv")
	timestamp := "2025-10-22T12:00:00Z"

	results := []ImageCVE{
		{
			Registry: "registry.redhat.io",
			Name:     "openshift4/ose-operator",
			SHA:      "sha256:abc123",
			CVEs: CVEsBySeverity{
				Critical: []string{"CVE-2024-0001"},
				High:     []string{"CVE-2024-0002", "CVE-2024-0003"},
				Medium:   []string{},
				Low:      []string{},
			},
		},
	}

	err := outputCSV(results, outputFile, timestamp)
	if err != nil {
		t.Fatalf("outputCSV() error = %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		t.Error("Output file was not created")
	}

	// Read and verify content
	content, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatalf("Failed to read output file: %v", err)
	}

	contentStr := string(content)
	expectedStrings := []string{
		"# Generated at: 2025-10-22T12:00:00Z",
		"Registry,Image Name,Image SHA,Critical CVEs,High CVEs,Medium CVEs,Low CVEs",
		"registry.redhat.io",
		"openshift4/ose-operator",
		"CVE-2024-0001",
		"CVE-2024-0002;CVE-2024-0003",
	}

	for _, expected := range expectedStrings {
		if !contains(contentStr, expected) {
			t.Errorf("Output CSV missing expected string: %s", expected)
		}
	}
}

func TestOutputMarkdown(t *testing.T) {
	tempDir := t.TempDir()
	outputFile := filepath.Join(tempDir, "test-output.md")
	timestamp := "2025-10-22T12:00:00Z"

	results := []ImageCVE{
		{
			Registry: "registry.redhat.io",
			Name:     "openshift4/ose-operator",
			SHA:      "sha256:abc123",
			CVEs: CVEsBySeverity{
				Critical: []string{"CVE-2024-0001"},
				High:     []string{"CVE-2024-0002"},
				Medium:   []string{"CVE-2024-0003"},
				Low:      []string{"CVE-2024-0004"},
			},
		},
	}

	err := outputMarkdown(results, outputFile, timestamp)
	if err != nil {
		t.Fatalf("outputMarkdown() error = %v", err)
	}

	// Verify file exists
	if _, err := os.Stat(outputFile); os.IsNotExist(err) {
		t.Error("Output file was not created")
	}

	// Read and verify content
	content, err := os.ReadFile(outputFile)
	if err != nil {
		t.Fatalf("Failed to read output file: %v", err)
	}

	contentStr := string(content)
	expectedStrings := []string{
		"# Container Image CVE Scan Results",
		"**Generated at:** 2025-10-22T12:00:00Z",
		"| Registry | Image Name | Image SHA | Critical | High | Medium | Low |",
		"registry.redhat.io",
		"openshift4/ose-operator",
		"## Detailed CVE Lists",
		"**Critical:**",
		"- CVE-2024-0001",
		"**High:**",
		"- CVE-2024-0002",
		"**Medium:**",
		"- CVE-2024-0003",
		"**Low:**",
		"- CVE-2024-0004",
	}

	for _, expected := range expectedStrings {
		if !contains(contentStr, expected) {
			t.Errorf("Output Markdown missing expected string: %s", expected)
		}
	}
}

// Helper function to check if a string contains a substring
func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(substr) == 0 ||
		(len(s) > 0 && len(substr) > 0 && hasSubstring(s, substr)))
}

func hasSubstring(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
