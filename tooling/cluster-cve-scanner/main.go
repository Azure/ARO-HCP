// Copyright 2025 Microsoft Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"context"
	"encoding/csv"
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"time"

	"gopkg.in/yaml.v3"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
)

type Config struct {
	Namespaces            []string          `yaml:"namespaces"`
	RegistrySubstitutions map[string]string `yaml:"registry_substitutions"`
}

type TrivyResult struct {
	Results []struct {
		Vulnerabilities []struct {
			VulnerabilityID string `json:"VulnerabilityID"`
			Severity        string `json:"Severity"`
		} `json:"Vulnerabilities"`
	} `json:"Results"`
}

type CVEsBySeverity struct {
	Critical []string `json:"critical"`
	High     []string `json:"high"`
	Medium   []string `json:"medium"`
	Low      []string `json:"low"`
}

type ImageCVE struct {
	Registry string         `json:"registry"`
	Name     string         `json:"image_name"`
	SHA      string         `json:"image_sha"`
	CVEs     CVEsBySeverity `json:"cves"`
}

func main() {
	outputFormat := flag.String("format", "json", "Output format: json, csv, or markdown")
	configFile := flag.String("config", "config.yaml", "Path to configuration file")
	flag.Parse()

	if err := run(*outputFormat, *configFile); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}
}

func run(outputFormat, configFile string) error {
	// Validate output format
	validFormats := map[string]bool{"json": true, "csv": true, "markdown": true}
	if !validFormats[outputFormat] {
		return fmt.Errorf("invalid output format: %s (must be json, csv, or markdown)", outputFormat)
	}

	// Load configuration
	config, err := loadConfig(configFile)
	if err != nil {
		return fmt.Errorf("failed to load config: %w", err)
	}

	if len(config.Namespaces) == 0 {
		return fmt.Errorf("no namespaces defined in config file")
	}

	// Get Kubernetes client
	clientset, err := getKubernetesClient()
	if err != nil {
		return fmt.Errorf("failed to get kubernetes client: %w", err)
	}

	// Get all images from specified namespaces
	images, err := getImagesFromNamespaces(clientset, config.Namespaces)
	if err != nil {
		return fmt.Errorf("failed to get images: %w", err)
	}

	if len(images) == 0 {
		fmt.Println("No images found in the specified namespaces")
		return nil
	}

	fmt.Printf("Found %d unique images from specified namespaces\n\n", len(images))

	// Scan images with trivy
	results := make([]ImageCVE, 0, len(images))
	for i, image := range images {
		fmt.Printf("Scanning %d/%d: %s\n", i+1, len(images), image)
		cve, err := scanImageWithTrivy(image, config.RegistrySubstitutions)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: failed to scan %s: %v\n", image, err)
			continue
		}
		results = append(results, cve)
	}

	// Generate timestamp for output
	timestamp := time.Now().UTC().Format(time.RFC3339)

	// Output results in requested format
	var outputFile string
	switch outputFormat {
	case "json":
		outputFile = "cluster-cve-results.json"
		if err := outputJSON(results, outputFile, timestamp); err != nil {
			return fmt.Errorf("failed to output JSON: %w", err)
		}
	case "csv":
		outputFile = "cluster-cve-results.csv"
		if err := outputCSV(results, outputFile, timestamp); err != nil {
			return fmt.Errorf("failed to output CSV: %w", err)
		}
	case "markdown":
		outputFile = "cluster-cve-results.md"
		if err := outputMarkdown(results, outputFile, timestamp); err != nil {
			return fmt.Errorf("failed to output Markdown: %w", err)
		}
	}

	fmt.Printf("\nSuccessfully scanned %d images and saved results to %s\n", len(results), outputFile)
	return nil
}

func getKubernetesClient() (*kubernetes.Clientset, error) {
	loadingRules := clientcmd.NewDefaultClientConfigLoadingRules()
	configOverrides := &clientcmd.ConfigOverrides{}
	kubeConfig := clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, configOverrides)

	config, err := kubeConfig.ClientConfig()
	if err != nil {
		return nil, err
	}

	return kubernetes.NewForConfig(config)
}

func loadConfig(configFile string) (*Config, error) {
	// Get absolute path relative to executable or current directory
	absPath := configFile
	if !filepath.IsAbs(configFile) {
		// Try relative to current directory first
		if _, err := os.Stat(configFile); err != nil {
			// If not found, try relative to executable
			execPath, err := os.Executable()
			if err == nil {
				absPath = filepath.Join(filepath.Dir(execPath), configFile)
			}
		}
	}

	// Read config file
	data, err := os.ReadFile(absPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read config file %s: %w", absPath, err)
	}

	// Parse YAML
	var config Config
	if err := yaml.Unmarshal(data, &config); err != nil {
		return nil, fmt.Errorf("failed to parse config file: %w", err)
	}

	return &config, nil
}

func getImagesFromNamespaces(clientset *kubernetes.Clientset, namespaces []string) ([]string, error) {
	ctx := context.Background()

	// Get all namespaces to match against patterns
	nsList, err := clientset.CoreV1().Namespaces().List(ctx, metav1.ListOptions{})
	if err != nil {
		return nil, fmt.Errorf("failed to list namespaces: %w", err)
	}

	// Build list of namespaces to scan (handling wildcards)
	namespacesToScan := make(map[string]bool)
	for _, nsPattern := range namespaces {
		if strings.HasSuffix(nsPattern, "*") {
			// Handle wildcard pattern
			prefix := strings.TrimSuffix(nsPattern, "*")
			for _, ns := range nsList.Items {
				if strings.HasPrefix(ns.Name, prefix) {
					namespacesToScan[ns.Name] = true
				}
			}
		} else {
			// Exact namespace name
			namespacesToScan[nsPattern] = true
		}
	}

	// Extract unique images from all pods in target namespaces
	imageSet := make(map[string]bool)
	for namespace := range namespacesToScan {
		pods, err := clientset.CoreV1().Pods(namespace).List(ctx, metav1.ListOptions{})
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: failed to list pods in namespace %s: %v\n", namespace, err)
			continue
		}

		for _, pod := range pods.Items {
			// Check init containers
			for _, container := range pod.Spec.InitContainers {
				imageSet[container.Image] = true
			}
			// Check regular containers
			for _, container := range pod.Spec.Containers {
				imageSet[container.Image] = true
			}
		}
	}

	// Convert set to slice
	images := make([]string, 0, len(imageSet))
	for image := range imageSet {
		images = append(images, image)
	}

	sort.Strings(images)
	return images, nil
}

func applyRegistrySubstitutions(image string, substitutions map[string]string) string {
	if len(substitutions) == 0 {
		return image
	}

	// Extract the registry from the image
	// Image format: registry/image-name or registry:port/image-name
	firstSlash := strings.Index(image, "/")
	if firstSlash == -1 {
		// No registry specified, default to docker.io
		return image
	}

	currentRegistry := image[:firstSlash]
	remainder := image[firstSlash:]

	// Check if there's a substitution for this registry
	for source, target := range substitutions {
		// Handle both exact matches and port variations
		// e.g., registry.redhat.io and registry.redhat.io:443
		if currentRegistry == source || strings.HasPrefix(currentRegistry, source+":") {
			return target + remainder
		}
	}

	return image
}

func scanImageWithTrivy(image string, registrySubstitutions map[string]string) (ImageCVE, error) {
	// Parse original image reference for the result (preserves original registry)
	registry, imageName, sha := parseImageReference(image)

	result := ImageCVE{
		Registry: registry,
		Name:     imageName,
		SHA:      sha,
		CVEs: CVEsBySeverity{
			Critical: []string{},
			High:     []string{},
			Medium:   []string{},
			Low:      []string{},
		},
	}

	// Apply registry substitutions for scanning (only affects the pull/scan)
	imageToScan := applyRegistrySubstitutions(image, registrySubstitutions)

	// Debug: show what we're actually scanning
	if imageToScan != image {
		fmt.Printf("  -> Scanning from: %s\n", imageToScan)
	}

	// Run trivy scan with substituted image (preserve :443 port as-is for Docker compatibility)
	cmd := exec.Command("trivy", "image", "--format", "json", "--quiet", imageToScan)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return result, fmt.Errorf("trivy scan failed: %w (output: %s)", err, string(output))
	}

	// Parse trivy output
	var trivyResult TrivyResult
	if err := json.Unmarshal(output, &trivyResult); err != nil {
		return result, fmt.Errorf("failed to parse trivy output: %w", err)
	}

	// Collect CVE IDs by severity
	for _, r := range trivyResult.Results {
		for _, vuln := range r.Vulnerabilities {
			cveID := vuln.VulnerabilityID
			if cveID == "" {
				continue
			}
			switch vuln.Severity {
			case "CRITICAL":
				result.CVEs.Critical = append(result.CVEs.Critical, cveID)
			case "HIGH":
				result.CVEs.High = append(result.CVEs.High, cveID)
			case "MEDIUM":
				result.CVEs.Medium = append(result.CVEs.Medium, cveID)
			case "LOW":
				result.CVEs.Low = append(result.CVEs.Low, cveID)
			}
		}
	}

	return result, nil
}

func parseImageReference(image string) (registry, imageName, sha string) {
	// Image format: "registry/image-repo/image-name@sha256:..."
	// or "registry:port/image-repo/image-name@sha256:..."

	// Extract SHA first
	shaIndex := strings.Index(image, "@sha256:")
	if shaIndex != -1 {
		sha = image[shaIndex+1:] // "sha256:..."
		image = image[:shaIndex] // Remove SHA from image string
	} else {
		// If no SHA, check for tag
		lastColon := strings.LastIndex(image, ":")
		if lastColon != -1 {
			// Check if this is a port (registry:443) or a tag
			slashAfterColon := strings.Index(image[lastColon:], "/")
			if slashAfterColon == -1 {
				// No slash after colon, it's a tag
				sha = image[lastColon+1:]
				image = image[:lastColon]
			}
		}
		if sha == "" {
			sha = "latest"
		}
	}

	// Extract registry (everything before first slash)
	firstSlash := strings.Index(image, "/")
	if firstSlash != -1 {
		registry = image[:firstSlash]
		imageName = image[firstSlash+1:] // Everything after registry/
	} else {
		// No slash found, entire string is the image name
		registry = "docker.io" // Default registry
		imageName = image
	}

	// Normalize registry by removing port if present
	registry = strings.Replace(registry, ":443", "", 1)

	return registry, imageName, sha
}

func outputJSON(results []ImageCVE, outputFile string, timestamp string) error {
	// Create wrapper structure with metadata
	output := map[string]interface{}{
		"generated_at": timestamp,
		"image_count":  len(results),
		"results":      results,
	}

	// Marshal results to JSON with indentation
	jsonData, err := json.MarshalIndent(output, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal JSON: %w", err)
	}

	// Write to file
	if err := os.WriteFile(outputFile, jsonData, 0644); err != nil {
		return fmt.Errorf("failed to write JSON file: %w", err)
	}

	return nil
}

func outputCSV(results []ImageCVE, outputFile string, timestamp string) error {
	file, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("failed to create CSV file: %w", err)
	}
	defer file.Close()

	// Write timestamp as comment
	if _, err := fmt.Fprintf(file, "# Generated at: %s\n", timestamp); err != nil {
		return fmt.Errorf("failed to write CSV timestamp: %w", err)
	}

	writer := csv.NewWriter(file)
	defer writer.Flush()

	// Write header
	header := []string{"Registry", "Image Name", "Image SHA", "Critical CVEs", "High CVEs", "Medium CVEs", "Low CVEs"}
	if err := writer.Write(header); err != nil {
		return fmt.Errorf("failed to write CSV header: %w", err)
	}

	// Write data rows
	for _, result := range results {
		row := []string{
			result.Registry,
			result.Name,
			result.SHA,
			strings.Join(result.CVEs.Critical, ";"),
			strings.Join(result.CVEs.High, ";"),
			strings.Join(result.CVEs.Medium, ";"),
			strings.Join(result.CVEs.Low, ";"),
		}
		if err := writer.Write(row); err != nil {
			return fmt.Errorf("failed to write CSV row: %w", err)
		}
	}

	return nil
}

func outputMarkdown(results []ImageCVE, outputFile string, timestamp string) error {
	file, err := os.Create(outputFile)
	if err != nil {
		return fmt.Errorf("failed to create Markdown file: %w", err)
	}
	defer file.Close()

	// Write title and timestamp
	fmt.Fprintln(file, "# Container Image CVE Scan Results")
	fmt.Fprintf(file, "\n**Generated at:** %s\n", timestamp)
	fmt.Fprintln(file, "")

	// Write table header
	fmt.Fprintln(file, "| Registry | Image Name | Image SHA | Critical | High | Medium | Low |")
	fmt.Fprintln(file, "|----------|------------|-----------|----------|------|--------|-----|")

	// Write data rows
	for _, result := range results {
		criticalCount := len(result.CVEs.Critical)
		highCount := len(result.CVEs.High)
		mediumCount := len(result.CVEs.Medium)
		lowCount := len(result.CVEs.Low)

		fmt.Fprintf(file, "| %s | %s | %s | %d | %d | %d | %d |\n",
			result.Registry,
			result.Name,
			result.SHA,
			criticalCount,
			highCount,
			mediumCount,
			lowCount,
		)
	}

	// Write detailed CVE lists
	fmt.Fprintln(file, "")
	fmt.Fprintln(file, "## Detailed CVE Lists")
	fmt.Fprintln(file, "")

	for _, result := range results {
		fmt.Fprintf(file, "### %s/%s@%s\n", result.Registry, result.Name, result.SHA)
		fmt.Fprintln(file, "")

		if len(result.CVEs.Critical) > 0 {
			fmt.Fprintln(file, "**Critical:**")
			for _, cve := range result.CVEs.Critical {
				fmt.Fprintf(file, "- %s\n", cve)
			}
			fmt.Fprintln(file, "")
		}

		if len(result.CVEs.High) > 0 {
			fmt.Fprintln(file, "**High:**")
			for _, cve := range result.CVEs.High {
				fmt.Fprintf(file, "- %s\n", cve)
			}
			fmt.Fprintln(file, "")
		}

		if len(result.CVEs.Medium) > 0 {
			fmt.Fprintln(file, "**Medium:**")
			for _, cve := range result.CVEs.Medium {
				fmt.Fprintf(file, "- %s\n", cve)
			}
			fmt.Fprintln(file, "")
		}

		if len(result.CVEs.Low) > 0 {
			fmt.Fprintln(file, "**Low:**")
			for _, cve := range result.CVEs.Low {
				fmt.Fprintf(file, "- %s\n", cve)
			}
			fmt.Fprintln(file, "")
		}
	}

	return nil
}
