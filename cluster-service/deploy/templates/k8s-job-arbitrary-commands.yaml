{{ if .Values.deployDebugJob }}
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: cs-arbitrary-commands
  namespace: '{{ .Release.Namespace }}'
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: cs-arbitrary-commands-role
  namespace: '{{ .Release.Namespace }}'
rules:
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list", "watch"]
  - apiGroups: ["apps"]
    resources: ["deployments"]
    verbs: ["get", "list", "watch"]
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: cs-arbitrary-commands-rolebinding
  namespace: '{{ .Release.Namespace }}'
subjects:
  - kind: ServiceAccount
    name: cs-arbitrary-commands
    namespace: '{{ .Release.Namespace }}'
roleRef:
  kind: Role
  name: cs-arbitrary-commands-role
  apiGroup: rbac.authorization.k8s.io
---
apiVersion: batch/v1
kind: Job
metadata:
  name: cs-arbitrary-commands
  namespace: '{{ .Release.Namespace }}'
spec:
  ttlSecondsAfterFinished: 300
  activeDeadlineSeconds: 900
  template:
    spec:
      serviceAccountName: cs-arbitrary-commands
      restartPolicy: Never
      containers:
      - name: cs-arbitrary-commands
        image: 'mcr.microsoft.com/aks/command/runtime:master.240118.1'
        command: ["/bin/sh", "-c"]
        args:
          - |
            checkImageTag() {
              local EXPECTED_TAG="$1"
              
              # Verifying all running pods have the same image version
              IMAGES=$(kubectl get pods -l app=clusters-service -o jsonpath='{range .items[*]}{.spec.containers[*].image}{"\n"}{end}' | sort | uniq)
              IMAGE_COUNT=$(echo "$IMAGES" | wc -l)
              if [ "$IMAGE_COUNT" -ne 1 ]; then
                echo "Error: Multiple image versions detected:"
                echo "$IMAGES"
                exit 1
              fi
              
              # Verifying image tag is the expected one
              DEPLOYMENT_IMAGE=$(kubectl get deployment clusters-service -o jsonpath='{.spec.template.spec.containers[0].image}')
              if [ "${DEPLOYMENT_IMAGE##*@}" != "$EXPECTED_TAG" ]; then
                echo "Error: Deployment is using the wrong image tag"
                echo "Current image: $DEPLOYMENT_IMAGE | Expected: $EXPECTED_TAG"
                exit 1
              fi

              # Check if all running pods also have the correct tag
              POD_IMAGES=$(kubectl get pods -l app=clusters-service -o jsonpath='{range .items[*]}{.spec.containers[*].image}{"\n"}{end}' | sort | uniq)
              # Verifying all running pods use the expected tag
              for image in $POD_IMAGES; do
                if [ "${image##*@}" != "$EXPECTED_TAG" ]; then
                  echo "Error: Pod image incorrect: $image"
                  exit 1
                fi
              done
              
              echo "All image tag checks passed successfully for tag: $EXPECTED_TAG"
            }
            
            echo "Starting execution..."
            
            # Wait for clusters-service deployment rollout to complete
            kubectl rollout status deployment/clusters-service --timeout=600s
            
            # Set the expected image tag
            EXPECTED_IMAGE_TAG={{ .Values.imageDigest }}
            
            checkImageTag "$EXPECTED_IMAGE_TAG"
            
            # Run your arbitrary commands below

            echo "\n=== Testing clusters-service API endpoint ==="
            curl -sS -X GET http://clusters-service:8000/api/clusters_mgmt/v1/provision_shards

            echo "\n\nExecution completed successfully"
{{ end }}