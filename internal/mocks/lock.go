// Code generated by MockGen. DO NOT EDIT.
// Source: ../database/lock.go
//
// Generated by this command:
//
//	mockgen-v0.5.0 -typed -source=../database/lock.go -destination=lock.go -package mocks github.com/Azure/ARO-HCP/internal/database LockClientInterface
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	http "net/http"
	reflect "reflect"
	time "time"

	azcosmos "github.com/Azure/azure-sdk-for-go/sdk/data/azcosmos"
	gomock "go.uber.org/mock/gomock"

	database "github.com/Azure/ARO-HCP/internal/database"
)

// MockLockClientInterface is a mock of LockClientInterface interface.
type MockLockClientInterface struct {
	ctrl     *gomock.Controller
	recorder *MockLockClientInterfaceMockRecorder
	isgomock struct{}
}

// MockLockClientInterfaceMockRecorder is the mock recorder for MockLockClientInterface.
type MockLockClientInterfaceMockRecorder struct {
	mock *MockLockClientInterface
}

// NewMockLockClientInterface creates a new mock instance.
func NewMockLockClientInterface(ctrl *gomock.Controller) *MockLockClientInterface {
	mock := &MockLockClientInterface{ctrl: ctrl}
	mock.recorder = &MockLockClientInterfaceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLockClientInterface) EXPECT() *MockLockClientInterfaceMockRecorder {
	return m.recorder
}

// AcquireLock mocks base method.
func (m *MockLockClientInterface) AcquireLock(ctx context.Context, id string, timeout *time.Duration) (*azcosmos.ItemResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AcquireLock", ctx, id, timeout)
	ret0, _ := ret[0].(*azcosmos.ItemResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AcquireLock indicates an expected call of AcquireLock.
func (mr *MockLockClientInterfaceMockRecorder) AcquireLock(ctx, id, timeout any) *MockLockClientInterfaceAcquireLockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AcquireLock", reflect.TypeOf((*MockLockClientInterface)(nil).AcquireLock), ctx, id, timeout)
	return &MockLockClientInterfaceAcquireLockCall{Call: call}
}

// MockLockClientInterfaceAcquireLockCall wrap *gomock.Call
type MockLockClientInterfaceAcquireLockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLockClientInterfaceAcquireLockCall) Return(arg0 *azcosmos.ItemResponse, arg1 error) *MockLockClientInterfaceAcquireLockCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLockClientInterfaceAcquireLockCall) Do(f func(context.Context, string, *time.Duration) (*azcosmos.ItemResponse, error)) *MockLockClientInterfaceAcquireLockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLockClientInterfaceAcquireLockCall) DoAndReturn(f func(context.Context, string, *time.Duration) (*azcosmos.ItemResponse, error)) *MockLockClientInterfaceAcquireLockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetDefaultTimeToLive mocks base method.
func (m *MockLockClientInterface) GetDefaultTimeToLive() time.Duration {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetDefaultTimeToLive")
	ret0, _ := ret[0].(time.Duration)
	return ret0
}

// GetDefaultTimeToLive indicates an expected call of GetDefaultTimeToLive.
func (mr *MockLockClientInterfaceMockRecorder) GetDefaultTimeToLive() *MockLockClientInterfaceGetDefaultTimeToLiveCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetDefaultTimeToLive", reflect.TypeOf((*MockLockClientInterface)(nil).GetDefaultTimeToLive))
	return &MockLockClientInterfaceGetDefaultTimeToLiveCall{Call: call}
}

// MockLockClientInterfaceGetDefaultTimeToLiveCall wrap *gomock.Call
type MockLockClientInterfaceGetDefaultTimeToLiveCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLockClientInterfaceGetDefaultTimeToLiveCall) Return(arg0 time.Duration) *MockLockClientInterfaceGetDefaultTimeToLiveCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLockClientInterfaceGetDefaultTimeToLiveCall) Do(f func() time.Duration) *MockLockClientInterfaceGetDefaultTimeToLiveCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLockClientInterfaceGetDefaultTimeToLiveCall) DoAndReturn(f func() time.Duration) *MockLockClientInterfaceGetDefaultTimeToLiveCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HoldLock mocks base method.
func (m *MockLockClientInterface) HoldLock(ctx context.Context, item *azcosmos.ItemResponse) (context.Context, database.StopHoldLock) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HoldLock", ctx, item)
	ret0, _ := ret[0].(context.Context)
	ret1, _ := ret[1].(database.StopHoldLock)
	return ret0, ret1
}

// HoldLock indicates an expected call of HoldLock.
func (mr *MockLockClientInterfaceMockRecorder) HoldLock(ctx, item any) *MockLockClientInterfaceHoldLockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HoldLock", reflect.TypeOf((*MockLockClientInterface)(nil).HoldLock), ctx, item)
	return &MockLockClientInterfaceHoldLockCall{Call: call}
}

// MockLockClientInterfaceHoldLockCall wrap *gomock.Call
type MockLockClientInterfaceHoldLockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLockClientInterfaceHoldLockCall) Return(arg0 context.Context, arg1 database.StopHoldLock) *MockLockClientInterfaceHoldLockCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLockClientInterfaceHoldLockCall) Do(f func(context.Context, *azcosmos.ItemResponse) (context.Context, database.StopHoldLock)) *MockLockClientInterfaceHoldLockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLockClientInterfaceHoldLockCall) DoAndReturn(f func(context.Context, *azcosmos.ItemResponse) (context.Context, database.StopHoldLock)) *MockLockClientInterfaceHoldLockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReleaseLock mocks base method.
func (m *MockLockClientInterface) ReleaseLock(ctx context.Context, item *azcosmos.ItemResponse) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReleaseLock", ctx, item)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReleaseLock indicates an expected call of ReleaseLock.
func (mr *MockLockClientInterfaceMockRecorder) ReleaseLock(ctx, item any) *MockLockClientInterfaceReleaseLockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReleaseLock", reflect.TypeOf((*MockLockClientInterface)(nil).ReleaseLock), ctx, item)
	return &MockLockClientInterfaceReleaseLockCall{Call: call}
}

// MockLockClientInterfaceReleaseLockCall wrap *gomock.Call
type MockLockClientInterfaceReleaseLockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLockClientInterfaceReleaseLockCall) Return(arg0 error) *MockLockClientInterfaceReleaseLockCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLockClientInterfaceReleaseLockCall) Do(f func(context.Context, *azcosmos.ItemResponse) error) *MockLockClientInterfaceReleaseLockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLockClientInterfaceReleaseLockCall) DoAndReturn(f func(context.Context, *azcosmos.ItemResponse) error) *MockLockClientInterfaceReleaseLockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RenewLock mocks base method.
func (m *MockLockClientInterface) RenewLock(ctx context.Context, item *azcosmos.ItemResponse) (*azcosmos.ItemResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RenewLock", ctx, item)
	ret0, _ := ret[0].(*azcosmos.ItemResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RenewLock indicates an expected call of RenewLock.
func (mr *MockLockClientInterfaceMockRecorder) RenewLock(ctx, item any) *MockLockClientInterfaceRenewLockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RenewLock", reflect.TypeOf((*MockLockClientInterface)(nil).RenewLock), ctx, item)
	return &MockLockClientInterfaceRenewLockCall{Call: call}
}

// MockLockClientInterfaceRenewLockCall wrap *gomock.Call
type MockLockClientInterfaceRenewLockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLockClientInterfaceRenewLockCall) Return(arg0 *azcosmos.ItemResponse, arg1 error) *MockLockClientInterfaceRenewLockCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLockClientInterfaceRenewLockCall) Do(f func(context.Context, *azcosmos.ItemResponse) (*azcosmos.ItemResponse, error)) *MockLockClientInterfaceRenewLockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLockClientInterfaceRenewLockCall) DoAndReturn(f func(context.Context, *azcosmos.ItemResponse) (*azcosmos.ItemResponse, error)) *MockLockClientInterfaceRenewLockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SetRetryAfterHeader mocks base method.
func (m *MockLockClientInterface) SetRetryAfterHeader(header http.Header) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetRetryAfterHeader", header)
}

// SetRetryAfterHeader indicates an expected call of SetRetryAfterHeader.
func (mr *MockLockClientInterfaceMockRecorder) SetRetryAfterHeader(header any) *MockLockClientInterfaceSetRetryAfterHeaderCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetRetryAfterHeader", reflect.TypeOf((*MockLockClientInterface)(nil).SetRetryAfterHeader), header)
	return &MockLockClientInterfaceSetRetryAfterHeaderCall{Call: call}
}

// MockLockClientInterfaceSetRetryAfterHeaderCall wrap *gomock.Call
type MockLockClientInterfaceSetRetryAfterHeaderCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLockClientInterfaceSetRetryAfterHeaderCall) Return() *MockLockClientInterfaceSetRetryAfterHeaderCall {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLockClientInterfaceSetRetryAfterHeaderCall) Do(f func(http.Header)) *MockLockClientInterfaceSetRetryAfterHeaderCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLockClientInterfaceSetRetryAfterHeaderCall) DoAndReturn(f func(http.Header)) *MockLockClientInterfaceSetRetryAfterHeaderCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// TryAcquireLock mocks base method.
func (m *MockLockClientInterface) TryAcquireLock(ctx context.Context, id string) (*azcosmos.ItemResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TryAcquireLock", ctx, id)
	ret0, _ := ret[0].(*azcosmos.ItemResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TryAcquireLock indicates an expected call of TryAcquireLock.
func (mr *MockLockClientInterfaceMockRecorder) TryAcquireLock(ctx, id any) *MockLockClientInterfaceTryAcquireLockCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TryAcquireLock", reflect.TypeOf((*MockLockClientInterface)(nil).TryAcquireLock), ctx, id)
	return &MockLockClientInterfaceTryAcquireLockCall{Call: call}
}

// MockLockClientInterfaceTryAcquireLockCall wrap *gomock.Call
type MockLockClientInterfaceTryAcquireLockCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockLockClientInterfaceTryAcquireLockCall) Return(arg0 *azcosmos.ItemResponse, arg1 error) *MockLockClientInterfaceTryAcquireLockCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockLockClientInterfaceTryAcquireLockCall) Do(f func(context.Context, string) (*azcosmos.ItemResponse, error)) *MockLockClientInterfaceTryAcquireLockCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockLockClientInterfaceTryAcquireLockCall) DoAndReturn(f func(context.Context, string) (*azcosmos.ItemResponse, error)) *MockLockClientInterfaceTryAcquireLockCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
