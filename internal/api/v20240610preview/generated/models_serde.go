//go:build go1.18
// +build go1.18

// Code generated by Microsoft (R) AutoRest Code Generator (autorest: 3.10.2, generator: @autorest/go@4.0.0-preview.63)
// Changes may cause incorrect behavior and will be lost if the code is regenerated.
// Code generated by @autorest/go. DO NOT EDIT.

package generated

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type APIProfile.
func (a APIProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "url", a.URL)
	populate(objectMap, "visibility", a.Visibility)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type APIProfile.
func (a *APIProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "url":
				err = unpopulate(val, "URL", &a.URL)
			delete(rawMsg, key)
		case "visibility":
				err = unpopulate(val, "Visibility", &a.Visibility)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", a, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClaimProfile.
func (c ClaimProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "claim", c.Claim)
	populate(objectMap, "prefix", c.Prefix)
	populate(objectMap, "prefixPolicy", c.PrefixPolicy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClaimProfile.
func (c *ClaimProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "claim":
				err = unpopulate(val, "Claim", &c.Claim)
			delete(rawMsg, key)
		case "prefix":
				err = unpopulate(val, "Prefix", &c.Prefix)
			delete(rawMsg, key)
		case "prefixPolicy":
				err = unpopulate(val, "PrefixPolicy", &c.PrefixPolicy)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", c, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterPatchSpec.
func (c ClusterPatchSpec) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "disableUserWorkloadMonitoring", c.DisableUserWorkloadMonitoring)
	populate(objectMap, "proxy", c.Proxy)
	populate(objectMap, "version", c.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterPatchSpec.
func (c *ClusterPatchSpec) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableUserWorkloadMonitoring":
				err = unpopulate(val, "DisableUserWorkloadMonitoring", &c.DisableUserWorkloadMonitoring)
			delete(rawMsg, key)
		case "proxy":
				err = unpopulate(val, "Proxy", &c.Proxy)
			delete(rawMsg, key)
		case "version":
				err = unpopulate(val, "Version", &c.Version)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", c, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterSpec.
func (c ClusterSpec) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "api", c.API)
	populate(objectMap, "console", c.Console)
	populate(objectMap, "dns", c.DNS)
	populate(objectMap, "disableUserWorkloadMonitoring", c.DisableUserWorkloadMonitoring)
	populate(objectMap, "etcdEncryption", c.EtcdEncryption)
	populate(objectMap, "externalAuth", c.ExternalAuth)
	populate(objectMap, "fips", c.Fips)
	populate(objectMap, "ingress", c.Ingress)
	populate(objectMap, "issuerUrl", c.IssuerURL)
	populate(objectMap, "network", c.Network)
	populate(objectMap, "platform", c.Platform)
	populate(objectMap, "proxy", c.Proxy)
	populate(objectMap, "version", c.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterSpec.
func (c *ClusterSpec) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "api":
				err = unpopulate(val, "API", &c.API)
			delete(rawMsg, key)
		case "console":
				err = unpopulate(val, "Console", &c.Console)
			delete(rawMsg, key)
		case "dns":
				err = unpopulate(val, "DNS", &c.DNS)
			delete(rawMsg, key)
		case "disableUserWorkloadMonitoring":
				err = unpopulate(val, "DisableUserWorkloadMonitoring", &c.DisableUserWorkloadMonitoring)
			delete(rawMsg, key)
		case "etcdEncryption":
				err = unpopulate(val, "EtcdEncryption", &c.EtcdEncryption)
			delete(rawMsg, key)
		case "externalAuth":
				err = unpopulate(val, "ExternalAuth", &c.ExternalAuth)
			delete(rawMsg, key)
		case "fips":
				err = unpopulate(val, "Fips", &c.Fips)
			delete(rawMsg, key)
		case "ingress":
				err = unpopulate(val, "Ingress", &c.Ingress)
			delete(rawMsg, key)
		case "issuerUrl":
				err = unpopulate(val, "IssuerURL", &c.IssuerURL)
			delete(rawMsg, key)
		case "network":
				err = unpopulate(val, "Network", &c.Network)
			delete(rawMsg, key)
		case "platform":
				err = unpopulate(val, "Platform", &c.Platform)
			delete(rawMsg, key)
		case "proxy":
				err = unpopulate(val, "Proxy", &c.Proxy)
			delete(rawMsg, key)
		case "version":
				err = unpopulate(val, "Version", &c.Version)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", c, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ComponentsQjfoe3SchemasManagedserviceidentityupdatePropertiesUserassignedidentitiesAdditionalproperties.
func (c ComponentsQjfoe3SchemasManagedserviceidentityupdatePropertiesUserassignedidentitiesAdditionalproperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clientId", c.ClientID)
	populate(objectMap, "principalId", c.PrincipalID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ComponentsQjfoe3SchemasManagedserviceidentityupdatePropertiesUserassignedidentitiesAdditionalproperties.
func (c *ComponentsQjfoe3SchemasManagedserviceidentityupdatePropertiesUserassignedidentitiesAdditionalproperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
				err = unpopulate(val, "ClientID", &c.ClientID)
			delete(rawMsg, key)
		case "principalId":
				err = unpopulate(val, "PrincipalID", &c.PrincipalID)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", c, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConsoleProfile.
func (c ConsoleProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "url", c.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConsoleProfile.
func (c *ConsoleProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "url":
				err = unpopulate(val, "URL", &c.URL)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", c, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DNSProfile.
func (d DNSProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "baseDomain", d.BaseDomain)
	populate(objectMap, "baseDomainPrefix", d.BaseDomainPrefix)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DNSProfile.
func (d *DNSProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "baseDomain":
				err = unpopulate(val, "BaseDomain", &d.BaseDomain)
			delete(rawMsg, key)
		case "baseDomainPrefix":
				err = unpopulate(val, "BaseDomainPrefix", &d.BaseDomainPrefix)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", d, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorAdditionalInfo.
func (e ErrorAdditionalInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateAny(objectMap, "info", e.Info)
	populate(objectMap, "type", e.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorAdditionalInfo.
func (e *ErrorAdditionalInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "info":
				err = unpopulate(val, "Info", &e.Info)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &e.Type)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", e, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "additionalInfo", e.AdditionalInfo)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorDetail.
func (e *ErrorDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalInfo":
				err = unpopulate(val, "AdditionalInfo", &e.AdditionalInfo)
			delete(rawMsg, key)
		case "code":
				err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "details":
				err = unpopulate(val, "Details", &e.Details)
			delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		case "target":
				err = unpopulate(val, "Target", &e.Target)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", e, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ErrorResponse.
func (e ErrorResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "error", e.Error)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ErrorResponse.
func (e *ErrorResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
				err = unpopulate(val, "Error", &e.Error)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", e, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExternalAuthClaimProfile.
func (e ExternalAuthClaimProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "mappings", e.Mappings)
	populate(objectMap, "validationRules", e.ValidationRules)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExternalAuthClaimProfile.
func (e *ExternalAuthClaimProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "mappings":
				err = unpopulate(val, "Mappings", &e.Mappings)
			delete(rawMsg, key)
		case "validationRules":
				err = unpopulate(val, "ValidationRules", &e.ValidationRules)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", e, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExternalAuthClientComponentProfile.
func (e ExternalAuthClientComponentProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authClientNamespace", e.AuthClientNamespace)
	populate(objectMap, "name", e.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExternalAuthClientComponentProfile.
func (e *ExternalAuthClientComponentProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authClientNamespace":
				err = unpopulate(val, "AuthClientNamespace", &e.AuthClientNamespace)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", e, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExternalAuthClientProfile.
func (e ExternalAuthClientProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "component", e.Component)
	populate(objectMap, "extraScopes", e.ExtraScopes)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "secret", e.Secret)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExternalAuthClientProfile.
func (e *ExternalAuthClientProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "component":
				err = unpopulate(val, "Component", &e.Component)
			delete(rawMsg, key)
		case "extraScopes":
				err = unpopulate(val, "ExtraScopes", &e.ExtraScopes)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "secret":
				err = unpopulate(val, "Secret", &e.Secret)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", e, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExternalAuthConfigProfile.
func (e ExternalAuthConfigProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "enabled", e.Enabled)
	populate(objectMap, "externalAuths", e.ExternalAuths)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExternalAuthConfigProfile.
func (e *ExternalAuthConfigProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enabled":
				err = unpopulate(val, "Enabled", &e.Enabled)
			delete(rawMsg, key)
		case "externalAuths":
				err = unpopulate(val, "ExternalAuths", &e.ExternalAuths)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", e, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExternalAuthProfile.
func (e ExternalAuthProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "claim", e.Claim)
	populate(objectMap, "clients", e.Clients)
	populate(objectMap, "issuer", e.Issuer)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExternalAuthProfile.
func (e *ExternalAuthProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "claim":
				err = unpopulate(val, "Claim", &e.Claim)
			delete(rawMsg, key)
		case "clients":
				err = unpopulate(val, "Clients", &e.Clients)
			delete(rawMsg, key)
		case "issuer":
				err = unpopulate(val, "Issuer", &e.Issuer)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", e, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HcpOpenShiftClusterCredentials.
func (h HcpOpenShiftClusterCredentials) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "kubeadminPassword", h.KubeadminPassword)
	populate(objectMap, "kubeadminUsername", h.KubeadminUsername)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HcpOpenShiftClusterCredentials.
func (h *HcpOpenShiftClusterCredentials) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kubeadminPassword":
				err = unpopulate(val, "KubeadminPassword", &h.KubeadminPassword)
			delete(rawMsg, key)
		case "kubeadminUsername":
				err = unpopulate(val, "KubeadminUsername", &h.KubeadminUsername)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", h, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HcpOpenShiftClusterKubeconfig.
func (h HcpOpenShiftClusterKubeconfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "kubeconfig", h.Kubeconfig)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HcpOpenShiftClusterKubeconfig.
func (h *HcpOpenShiftClusterKubeconfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kubeconfig":
				err = unpopulate(val, "Kubeconfig", &h.Kubeconfig)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", h, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HcpOpenShiftClusterNodePoolPatch.
func (h HcpOpenShiftClusterNodePoolPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "identity", h.Identity)
	populate(objectMap, "properties", h.Properties)
	populate(objectMap, "tags", h.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HcpOpenShiftClusterNodePoolPatch.
func (h *HcpOpenShiftClusterNodePoolPatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
				err = unpopulate(val, "Identity", &h.Identity)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &h.Properties)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &h.Tags)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", h, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HcpOpenShiftClusterNodePoolResource.
func (h HcpOpenShiftClusterNodePoolResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", h.ID)
	populate(objectMap, "identity", h.Identity)
	populate(objectMap, "location", h.Location)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "properties", h.Properties)
	populate(objectMap, "systemData", h.SystemData)
	populate(objectMap, "tags", h.Tags)
	populate(objectMap, "type", h.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HcpOpenShiftClusterNodePoolResource.
func (h *HcpOpenShiftClusterNodePoolResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &h.ID)
			delete(rawMsg, key)
		case "identity":
				err = unpopulate(val, "Identity", &h.Identity)
			delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &h.Location)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &h.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &h.SystemData)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &h.Tags)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", h, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HcpOpenShiftClusterNodePoolResourceListResult.
func (h HcpOpenShiftClusterNodePoolResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", h.NextLink)
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HcpOpenShiftClusterNodePoolResourceListResult.
func (h *HcpOpenShiftClusterNodePoolResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &h.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &h.Value)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", h, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HcpOpenShiftClusterPatch.
func (h HcpOpenShiftClusterPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "identity", h.Identity)
	populate(objectMap, "properties", h.Properties)
	populate(objectMap, "tags", h.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HcpOpenShiftClusterPatch.
func (h *HcpOpenShiftClusterPatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identity":
				err = unpopulate(val, "Identity", &h.Identity)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &h.Properties)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &h.Tags)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", h, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HcpOpenShiftClusterPatchProperties.
func (h HcpOpenShiftClusterPatchProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "spec", h.Spec)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HcpOpenShiftClusterPatchProperties.
func (h *HcpOpenShiftClusterPatchProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "spec":
				err = unpopulate(val, "Spec", &h.Spec)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", h, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HcpOpenShiftClusterProperties.
func (h HcpOpenShiftClusterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "provisioningState", h.ProvisioningState)
	populate(objectMap, "spec", h.Spec)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HcpOpenShiftClusterProperties.
func (h *HcpOpenShiftClusterProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &h.ProvisioningState)
			delete(rawMsg, key)
		case "spec":
				err = unpopulate(val, "Spec", &h.Spec)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", h, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HcpOpenShiftClusterResource.
func (h HcpOpenShiftClusterResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", h.ID)
	populate(objectMap, "identity", h.Identity)
	populate(objectMap, "location", h.Location)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "properties", h.Properties)
	populate(objectMap, "systemData", h.SystemData)
	populate(objectMap, "tags", h.Tags)
	populate(objectMap, "type", h.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HcpOpenShiftClusterResource.
func (h *HcpOpenShiftClusterResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &h.ID)
			delete(rawMsg, key)
		case "identity":
				err = unpopulate(val, "Identity", &h.Identity)
			delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &h.Location)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &h.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &h.SystemData)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &h.Tags)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", h, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HcpOpenShiftClusterResourceListResult.
func (h HcpOpenShiftClusterResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", h.NextLink)
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HcpOpenShiftClusterResourceListResult.
func (h *HcpOpenShiftClusterResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &h.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &h.Value)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", h, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HcpOpenShiftVersionResource.
func (h HcpOpenShiftVersionResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", h.ID)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "properties", h.Properties)
	populate(objectMap, "systemData", h.SystemData)
	populate(objectMap, "type", h.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HcpOpenShiftVersionResource.
func (h *HcpOpenShiftVersionResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &h.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &h.Properties)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &h.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &h.Type)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", h, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HcpOpenShiftVersionResourceListResult.
func (h HcpOpenShiftVersionResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", h.NextLink)
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HcpOpenShiftVersionResourceListResult.
func (h *HcpOpenShiftVersionResourceListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &h.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &h.Value)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", h, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HcpOpenShiftVersionsProperties.
func (h HcpOpenShiftVersionsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clusterVersion", h.ClusterVersion)
	populate(objectMap, "provisioningState", h.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HcpOpenShiftVersionsProperties.
func (h *HcpOpenShiftVersionsProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clusterVersion":
				err = unpopulate(val, "ClusterVersion", &h.ClusterVersion)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &h.ProvisioningState)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", h, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IngressProfile.
func (i IngressProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ip", i.IP)
	populate(objectMap, "url", i.URL)
	populate(objectMap, "visibility", i.Visibility)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IngressProfile.
func (i *IngressProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ip":
				err = unpopulate(val, "IP", &i.IP)
			delete(rawMsg, key)
		case "url":
				err = unpopulate(val, "URL", &i.URL)
			delete(rawMsg, key)
		case "visibility":
				err = unpopulate(val, "Visibility", &i.Visibility)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", i, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Label.
func (l Label) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "key", l.Key)
	populate(objectMap, "value", l.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Label.
func (l *Label) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
				err = unpopulate(val, "Key", &l.Key)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &l.Value)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", l, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedServiceIdentity.
func (m ManagedServiceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "principalId", m.PrincipalID)
	populate(objectMap, "tenantId", m.TenantID)
	populate(objectMap, "type", m.Type)
	populate(objectMap, "userAssignedIdentities", m.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedServiceIdentity.
func (m *ManagedServiceIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "principalId":
				err = unpopulate(val, "PrincipalID", &m.PrincipalID)
			delete(rawMsg, key)
		case "tenantId":
				err = unpopulate(val, "TenantID", &m.TenantID)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "userAssignedIdentities":
				err = unpopulate(val, "UserAssignedIdentities", &m.UserAssignedIdentities)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", m, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedServiceIdentityUpdate.
func (m ManagedServiceIdentityUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "type", m.Type)
	populate(objectMap, "userAssignedIdentities", m.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedServiceIdentityUpdate.
func (m *ManagedServiceIdentityUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
				err = unpopulate(val, "Type", &m.Type)
			delete(rawMsg, key)
		case "userAssignedIdentities":
				err = unpopulate(val, "UserAssignedIdentities", &m.UserAssignedIdentities)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", m, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkProfile.
func (n NetworkProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "hostPrefix", n.HostPrefix)
	populate(objectMap, "machineCidr", n.MachineCidr)
	populate(objectMap, "networkType", n.NetworkType)
	populate(objectMap, "podCidr", n.PodCidr)
	populate(objectMap, "serviceCidr", n.ServiceCidr)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkProfile.
func (n *NetworkProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "hostPrefix":
				err = unpopulate(val, "HostPrefix", &n.HostPrefix)
			delete(rawMsg, key)
		case "machineCidr":
				err = unpopulate(val, "MachineCidr", &n.MachineCidr)
			delete(rawMsg, key)
		case "networkType":
				err = unpopulate(val, "NetworkType", &n.NetworkType)
			delete(rawMsg, key)
		case "podCidr":
				err = unpopulate(val, "PodCidr", &n.PodCidr)
			delete(rawMsg, key)
		case "serviceCidr":
				err = unpopulate(val, "ServiceCidr", &n.ServiceCidr)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", n, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodePoolAutoScaling.
func (n NodePoolAutoScaling) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "max", n.Max)
	populate(objectMap, "min", n.Min)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodePoolAutoScaling.
func (n *NodePoolAutoScaling) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "max":
				err = unpopulate(val, "Max", &n.Max)
			delete(rawMsg, key)
		case "min":
				err = unpopulate(val, "Min", &n.Min)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", n, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodePoolPatchProperties.
func (n NodePoolPatchProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "spec", n.Spec)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodePoolPatchProperties.
func (n *NodePoolPatchProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "spec":
				err = unpopulate(val, "Spec", &n.Spec)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", n, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodePoolPatchSpec.
func (n NodePoolPatchSpec) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoScaling", n.AutoScaling)
	populate(objectMap, "labels", n.Labels)
	populate(objectMap, "replicas", n.Replicas)
	populate(objectMap, "taints", n.Taints)
	populate(objectMap, "tuningConfigs", n.TuningConfigs)
	populate(objectMap, "version", n.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodePoolPatchSpec.
func (n *NodePoolPatchSpec) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoScaling":
				err = unpopulate(val, "AutoScaling", &n.AutoScaling)
			delete(rawMsg, key)
		case "labels":
				err = unpopulate(val, "Labels", &n.Labels)
			delete(rawMsg, key)
		case "replicas":
				err = unpopulate(val, "Replicas", &n.Replicas)
			delete(rawMsg, key)
		case "taints":
				err = unpopulate(val, "Taints", &n.Taints)
			delete(rawMsg, key)
		case "tuningConfigs":
				err = unpopulate(val, "TuningConfigs", &n.TuningConfigs)
			delete(rawMsg, key)
		case "version":
				err = unpopulate(val, "Version", &n.Version)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", n, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodePoolPlatformProfile.
func (n NodePoolPlatformProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "availabilityZone", n.AvailabilityZone)
	populate(objectMap, "diskEncryptionSetId", n.DiskEncryptionSetID)
	populate(objectMap, "diskSizeGiB", n.DiskSizeGiB)
	populate(objectMap, "diskStorageAccountType", n.DiskStorageAccountType)
	populate(objectMap, "encryptionAtHost", n.EncryptionAtHost)
	populate(objectMap, "ephemeralOsDisk", n.EphemeralOsDisk)
	populate(objectMap, "subnetId", n.SubnetID)
	populate(objectMap, "vmSize", n.VMSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodePoolPlatformProfile.
func (n *NodePoolPlatformProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "availabilityZone":
				err = unpopulate(val, "AvailabilityZone", &n.AvailabilityZone)
			delete(rawMsg, key)
		case "diskEncryptionSetId":
				err = unpopulate(val, "DiskEncryptionSetID", &n.DiskEncryptionSetID)
			delete(rawMsg, key)
		case "diskSizeGiB":
				err = unpopulate(val, "DiskSizeGiB", &n.DiskSizeGiB)
			delete(rawMsg, key)
		case "diskStorageAccountType":
				err = unpopulate(val, "DiskStorageAccountType", &n.DiskStorageAccountType)
			delete(rawMsg, key)
		case "encryptionAtHost":
				err = unpopulate(val, "EncryptionAtHost", &n.EncryptionAtHost)
			delete(rawMsg, key)
		case "ephemeralOsDisk":
				err = unpopulate(val, "EphemeralOsDisk", &n.EphemeralOsDisk)
			delete(rawMsg, key)
		case "subnetId":
				err = unpopulate(val, "SubnetID", &n.SubnetID)
			delete(rawMsg, key)
		case "vmSize":
				err = unpopulate(val, "VMSize", &n.VMSize)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", n, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodePoolProperties.
func (n NodePoolProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "provisioningState", n.ProvisioningState)
	populate(objectMap, "spec", n.Spec)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodePoolProperties.
func (n *NodePoolProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &n.ProvisioningState)
			delete(rawMsg, key)
		case "spec":
				err = unpopulate(val, "Spec", &n.Spec)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", n, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NodePoolSpec.
func (n NodePoolSpec) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoRepair", n.AutoRepair)
	populate(objectMap, "autoScaling", n.AutoScaling)
	populate(objectMap, "labels", n.Labels)
	populate(objectMap, "platform", n.Platform)
	populate(objectMap, "replicas", n.Replicas)
	populate(objectMap, "taints", n.Taints)
	populate(objectMap, "tuningConfigs", n.TuningConfigs)
	populate(objectMap, "version", n.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NodePoolSpec.
func (n *NodePoolSpec) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoRepair":
				err = unpopulate(val, "AutoRepair", &n.AutoRepair)
			delete(rawMsg, key)
		case "autoScaling":
				err = unpopulate(val, "AutoScaling", &n.AutoScaling)
			delete(rawMsg, key)
		case "labels":
				err = unpopulate(val, "Labels", &n.Labels)
			delete(rawMsg, key)
		case "platform":
				err = unpopulate(val, "Platform", &n.Platform)
			delete(rawMsg, key)
		case "replicas":
				err = unpopulate(val, "Replicas", &n.Replicas)
			delete(rawMsg, key)
		case "taints":
				err = unpopulate(val, "Taints", &n.Taints)
			delete(rawMsg, key)
		case "tuningConfigs":
				err = unpopulate(val, "TuningConfigs", &n.TuningConfigs)
			delete(rawMsg, key)
		case "version":
				err = unpopulate(val, "Version", &n.Version)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", n, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actionType", o.ActionType)
	populate(objectMap, "display", o.Display)
	populate(objectMap, "isDataAction", o.IsDataAction)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "origin", o.Origin)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Operation.
func (o *Operation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actionType":
				err = unpopulate(val, "ActionType", &o.ActionType)
			delete(rawMsg, key)
		case "display":
				err = unpopulate(val, "Display", &o.Display)
			delete(rawMsg, key)
		case "isDataAction":
				err = unpopulate(val, "IsDataAction", &o.IsDataAction)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &o.Name)
			delete(rawMsg, key)
		case "origin":
				err = unpopulate(val, "Origin", &o.Origin)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", o, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "description", o.Description)
	populate(objectMap, "operation", o.Operation)
	populate(objectMap, "provider", o.Provider)
	populate(objectMap, "resource", o.Resource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationDisplay.
func (o *OperationDisplay) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "description":
				err = unpopulate(val, "Description", &o.Description)
			delete(rawMsg, key)
		case "operation":
				err = unpopulate(val, "Operation", &o.Operation)
			delete(rawMsg, key)
		case "provider":
				err = unpopulate(val, "Provider", &o.Provider)
			delete(rawMsg, key)
		case "resource":
				err = unpopulate(val, "Resource", &o.Resource)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", o, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OperationListResult.
func (o *OperationListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &o.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &o.Value)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", o, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PlatformProfile.
func (p PlatformProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "etcdEncryptionSetId", p.EtcdEncryptionSetID)
	populate(objectMap, "managedResourceGroup", p.ManagedResourceGroup)
	populate(objectMap, "networkSecurityGroupId", p.NetworkSecurityGroupID)
	populate(objectMap, "outboundType", p.OutboundType)
	populate(objectMap, "subnetId", p.SubnetID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PlatformProfile.
func (p *PlatformProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etcdEncryptionSetId":
				err = unpopulate(val, "EtcdEncryptionSetID", &p.EtcdEncryptionSetID)
			delete(rawMsg, key)
		case "managedResourceGroup":
				err = unpopulate(val, "ManagedResourceGroup", &p.ManagedResourceGroup)
			delete(rawMsg, key)
		case "networkSecurityGroupId":
				err = unpopulate(val, "NetworkSecurityGroupID", &p.NetworkSecurityGroupID)
			delete(rawMsg, key)
		case "outboundType":
				err = unpopulate(val, "OutboundType", &p.OutboundType)
			delete(rawMsg, key)
		case "subnetId":
				err = unpopulate(val, "SubnetID", &p.SubnetID)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", p, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProxyProfile.
func (p ProxyProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "httpProxy", p.HTTPProxy)
	populate(objectMap, "httpsProxy", p.HTTPSProxy)
	populate(objectMap, "noProxy", p.NoProxy)
	populate(objectMap, "trustedCa", p.TrustedCa)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProxyProfile.
func (p *ProxyProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "httpProxy":
				err = unpopulate(val, "HTTPProxy", &p.HTTPProxy)
			delete(rawMsg, key)
		case "httpsProxy":
				err = unpopulate(val, "HTTPSProxy", &p.HTTPSProxy)
			delete(rawMsg, key)
		case "noProxy":
				err = unpopulate(val, "NoProxy", &p.NoProxy)
			delete(rawMsg, key)
		case "trustedCa":
				err = unpopulate(val, "TrustedCa", &p.TrustedCa)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", p, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProxyResource.
func (p ProxyResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProxyResource.
func (p *ProxyResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &p.Name)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &p.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &p.Type)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", p, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "systemData", r.SystemData)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Resource.
func (r *Resource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &r.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &r.Name)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &r.SystemData)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &r.Type)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", r, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateDateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
				err = unpopulateDateTimeRFC3339(val, "CreatedAt", &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
				err = unpopulate(val, "CreatedBy", &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
				err = unpopulate(val, "CreatedByType", &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
				err = unpopulateDateTimeRFC3339(val, "LastModifiedAt", &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
				err = unpopulate(val, "LastModifiedBy", &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
				err = unpopulate(val, "LastModifiedByType", &s.LastModifiedByType)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", s, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Taint.
func (t Taint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "effect", t.Effect)
	populate(objectMap, "key", t.Key)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Taint.
func (t *Taint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "effect":
				err = unpopulate(val, "Effect", &t.Effect)
			delete(rawMsg, key)
		case "key":
				err = unpopulate(val, "Key", &t.Key)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &t.Value)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", t, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TokenClaimMappingsProfile.
func (t TokenClaimMappingsProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "groups", t.Groups)
	populate(objectMap, "username", t.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TokenClaimMappingsProfile.
func (t *TokenClaimMappingsProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "groups":
				err = unpopulate(val, "Groups", &t.Groups)
			delete(rawMsg, key)
		case "username":
				err = unpopulate(val, "Username", &t.Username)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", t, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TokenClaimValidationRuleProfile.
func (t TokenClaimValidationRuleProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "claim", t.Claim)
	populate(objectMap, "requiredValue", t.RequiredValue)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TokenClaimValidationRuleProfile.
func (t *TokenClaimValidationRuleProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "claim":
				err = unpopulate(val, "Claim", &t.Claim)
			delete(rawMsg, key)
		case "requiredValue":
				err = unpopulate(val, "RequiredValue", &t.RequiredValue)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", t, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TokenIssuerProfile.
func (t TokenIssuerProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "audiences", t.Audiences)
	populate(objectMap, "ca", t.Ca)
	populate(objectMap, "url", t.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TokenIssuerProfile.
func (t *TokenIssuerProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "audiences":
				err = unpopulate(val, "Audiences", &t.Audiences)
			delete(rawMsg, key)
		case "ca":
				err = unpopulate(val, "Ca", &t.Ca)
			delete(rawMsg, key)
		case "url":
				err = unpopulate(val, "URL", &t.URL)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", t, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", t.ID)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TrackedResource.
func (t *TrackedResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &t.ID)
			delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &t.Location)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &t.Name)
			delete(rawMsg, key)
		case "systemData":
				err = unpopulate(val, "SystemData", &t.SystemData)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &t.Tags)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &t.Type)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", t, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UserAssignedIdentity.
func (u UserAssignedIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clientId", u.ClientID)
	populate(objectMap, "principalId", u.PrincipalID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserAssignedIdentity.
func (u *UserAssignedIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
				err = unpopulate(val, "ClientID", &u.ClientID)
			delete(rawMsg, key)
		case "principalId":
				err = unpopulate(val, "PrincipalID", &u.PrincipalID)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", u, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VersionProfile.
func (v VersionProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "availableUpgrades", v.AvailableUpgrades)
	populate(objectMap, "channelGroup", v.ChannelGroup)
	populate(objectMap, "id", v.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VersionProfile.
func (v *VersionProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "availableUpgrades":
				err = unpopulate(val, "AvailableUpgrades", &v.AvailableUpgrades)
			delete(rawMsg, key)
		case "channelGroup":
				err = unpopulate(val, "ChannelGroup", &v.ChannelGroup)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &v.ID)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", v, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VersionProfileUpdate.
func (v VersionProfileUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", v.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VersionProfileUpdate.
func (v *VersionProfileUpdate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &v.ID)
			delete(rawMsg, key)
		default:
			err = fmt.Errorf("unmarshalling type %T, unknown field %q", v, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateAny(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}

